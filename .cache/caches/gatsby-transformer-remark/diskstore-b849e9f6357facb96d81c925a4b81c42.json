{"expireTime":9007200904342771000,"key":"transformer-remark-markdown-html-0f173beb055bb1ec26705ff4459c6cba--","val":"<h1>Array.prototype.reduce()</h1>\n<p>The <code>reduce()</code> method executes a <strong>reducer</strong> function (that you provide) on each element of the array, resulting in a single output value.</p>\n<p>The <strong>reducer</strong> function takes four arguments:</p>\n<ol>\n<li>Accumulator</li>\n<li>Current Value</li>\n<li>Current Index</li>\n<li>Source Array</li>\n</ol>\n<p>Your <strong>reducer</strong> function's returned value is assigned to the accumulator, whose value is remembered across each iteration throughout the array, and ultimately becomes the final, single resulting value.</p>\n<h2>Syntax</h2>\n<pre><code>// Arrow function\nreduce((accumulator, currentValue) => { ... } )\nreduce((accumulator, currentValue, index) => { ... } )\nreduce((accumulator, currentValue, index, array) => { ... } )\nreduce((accumulator, currentValue, index, array) => { ... }, initialValue)\n\n// Reducer function\nreduce(reducerFn)\nreduce(reducerFn, initialValue)\n\n// Inline reducer function\nreduce(function reducerFn(accumulator, currentValue) { ... })\nreduce(function reducerFn(accumulator, currentValue, index) { ... })\nreduce(function reducerFn(accumulator, currentValue, index, array){ ... })\nreduce(function reducerFn(accumulator, currentValue, index, array) { ... }, initialValue)\n</code></pre>\n<h3>Parameters</h3>\n<p><code>callback</code>\nA function to execute on each element in the array (except for the first, if no <code>initialValue</code> is supplied).</p>\n<p>It takes four arguments:</p>\n<p><code>accumulator</code>\nThe accumulator accumulates callback's return values. It is the accumulated value previously returned in the last invocation of the callbackâ€”or <code>initialValue</code>, if it was supplied (see below).</p>\n<p><code>currentValue</code>\nThe current element being processed in the array.</p>\n<p><code>index</code> <span class=\"badge inline optional\">Optional</span>\nThe index of the current element being processed in the array. Starts from index <code>0</code> if an <code>initialValue</code> is provided. Otherwise, it starts from index <code>1</code>.</p>\n<p><code>array</code> <span class=\"badge inline optional\">Optional</span>\nThe array <code>reduce()</code> was called upon.</p>\n<p><code>initialValue</code> <span class=\"badge inline optional\">Optional</span>\nA value to use as the first argument to the first call of the <code>callback</code>. If no <code>initialValue</code> is supplied, the first element in the array will be used as the initial <code>accumulator</code> value and skipped as <code>currentValue</code>. Calling <code>reduce()</code> on an empty array without an <code>initialValue</code> will throw a <a href=\"../typeerror\"><code>TypeError</code></a>.</p>\n<h3>Return value</h3>\n<p>The single value that results from the reduction.</p>\n<h2>Description</h2>\n<p>The <code>reduce()</code> method executes the <code>callback</code> once for each assigned value present in the array, taking four arguments:</p>\n<ol>\n<li><code>accumulator</code></li>\n<li><code>currentValue</code></li>\n<li><code>currentIndex</code></li>\n<li><code>array</code></li>\n</ol>\n<p>The first time the callback is called, <code>accumulator</code> and <code>currentValue</code> can be one of two values. If <code>initialValue</code> is provided in the call to <code>reduce()</code>, then <code>accumulator</code> will be equal to <code>initialValue</code>, and <code>currentValue</code> will be equal to the first value in the array. If no <code>initialValue</code> is provided, then <code>accumulator</code> will be equal to the first value in the array, and <code>currentValue</code> will be equal to the second.</p>\n<p><strong>Note:</strong> If <code>initialValue</code> is not provided, <code>reduce()</code> will execute the callback function starting at index <code>1</code>, skipping the first index. If <code>initialValue</code> is provided, it will start at index <code>0</code>.</p>\n<p>If the array is empty and no <code>initialValue</code> is provided, <a href=\"../typeerror\"><code>TypeError</code></a> will be thrown.</p>\n<p>If the array only has one element (regardless of position) and no <code>initialValue</code> is provided, or if <code>initialValue</code> is provided but the array is empty, the solo value will be returned <em>without</em> calling <em><code>callback</code>.</em></p>\n<p>It is almost always safer to provide an <code>initialValue</code>, because there can be up to <em>four</em> possible output types without <code>initialValue</code>, as shown in the following example:</p>\n<pre><code>let maxCallback = ( acc, cur ) => Math.max( acc.x, cur.x );\nlet maxCallback2 = ( max, cur ) => Math.max( max, cur );\n\n// reduce without initialValue\n[ { x: 2 }, { x: 22 }, { x: 42 } ].reduce( maxCallback ); // NaN\n[ { x: 2 }, { x: 22 }            ].reduce( maxCallback ); // 22\n[ { x: 2 }                       ].reduce( maxCallback ); // { x: 2 }\n[                                ].reduce( maxCallback ); // TypeError\n\n// map &#x26; reduce with initialValue; better solution, also works for empty or larger arrays\n[ { x: 22 }, { x: 42 } ].map( el => el.x )\n                        .reduce( maxCallback2, -Infinity );\n</code></pre>\n<h3>How reduce() works</h3>\n<p>Suppose the following use of <code>reduce()</code> occurred:</p>\n<pre><code>[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array) {\n  return accumulator + currentValue\n})\n</code></pre>\n<p>The callback would be invoked four times, with the arguments and return values in each call being as follows:</p>\n<table><thead><tr class=\"header\"><th><code>callback</code> iteration</th><th><code>accumulator</code></th><th><code>currentValue</code></th><th><code>currentIndex</code></th><th><code>array</code></th><th>return value</th></tr></thead><tbody><tr class=\"odd\"><td>first call</td><td><code>0</code></td><td><code>1</code></td><td><code>1</code></td><td><code>[0, 1, 2, 3, 4]</code></td><td><code>1</code></td></tr><tr class=\"even\"><td>second call</td><td><code>1</code></td><td><code>2</code></td><td><code>2</code></td><td><code>[0, 1, 2, 3, 4]</code></td><td><code>3</code></td></tr><tr class=\"odd\"><td>third call</td><td><code>3</code></td><td><code>3</code></td><td><code>3</code></td><td><code>[0, 1, 2, 3, 4]</code></td><td><code>6</code></td></tr><tr class=\"even\"><td>fourth call</td><td><code>6</code></td><td><code>4</code></td><td><code>4</code></td><td><code>[0, 1, 2, 3, 4]</code></td><td><code>10</code></td></tr></tbody></table>\n<p>The value returned by <code>reduce()</code> would be that of the last callback invocation (<code>10</code>).</p>\n<p>You can also provide an <a href=\"../../functions/arrow_functions\">Arrow Function</a> instead of a full function. The code below will produce the same output as the code in the block above:</p>\n<pre><code>[0, 1, 2, 3, 4].reduce( (accumulator, currentValue, currentIndex, array) => accumulator + currentValue )\n</code></pre>\n<p>If you were to provide an <code>initialValue</code> as the second argument to <code>reduce()</code>, the result would look like this:</p>\n<pre><code>[0, 1, 2, 3, 4].reduce((accumulator, currentValue, currentIndex, array) => {\n    return accumulator + currentValue\n}, 10)\n</code></pre>\n<table><thead><tr class=\"header\"><th><code>callback</code> iteration</th><th><code>accumulator</code></th><th><code>currentValue</code></th><th><code>currentIndex</code></th><th><code>array</code></th><th>return value</th></tr></thead><tbody><tr class=\"odd\"><td>first call</td><td><code>10</code></td><td><code>0</code></td><td><code>0</code></td><td><code>[0, 1, 2, 3, 4]</code></td><td><code>10</code></td></tr><tr class=\"even\"><td>second call</td><td><code>10</code></td><td><code>1</code></td><td><code>1</code></td><td><code>[0, 1, 2, 3, 4]</code></td><td><code>11</code></td></tr><tr class=\"odd\"><td>third call</td><td><code>11</code></td><td><code>2</code></td><td><code>2</code></td><td><code>[0, 1, 2, 3, 4]</code></td><td><code>13</code></td></tr><tr class=\"even\"><td>fourth call</td><td><code>13</code></td><td><code>3</code></td><td><code>3</code></td><td><code>[0, 1, 2, 3, 4]</code></td><td><code>16</code></td></tr><tr class=\"odd\"><td>fifth call</td><td><code>16</code></td><td><code>4</code></td><td><code>4</code></td><td><code>[0, 1, 2, 3, 4]</code></td><td><code>20</code></td></tr></tbody></table>\n<p>The value returned by <code>reduce()</code> in this case would be <code>20</code>.</p>\n<h2>Polyfill</h2>\n<pre><code>// Production steps of ECMA-262, Edition 5, 15.4.4.21\n// Reference: https://es5.github.io/#x15.4.4.21\n// https://tc39.github.io/ecma262/#sec-array.prototype.reduce\nif (!Array.prototype.reduce) {\n  Object.defineProperty(Array.prototype, 'reduce', {\n    value: function(callback /*, initialValue*/) {\n      if (this === null) {\n        throw new TypeError( 'Array.prototype.reduce ' +\n          'called on null or undefined' );\n      }\n      if (typeof callback !== 'function') {\n        throw new TypeError( callback +\n          ' is not a function');\n      }\n\n      // 1. Let O be ? ToObject(this value).\n      var o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      var len = o.length >>> 0;\n\n      // Steps 3, 4, 5, 6, 7\n      var k = 0;\n      var value;\n\n      if (arguments.length >= 2) {\n        value = arguments[1];\n      } else {\n        while (k &#x3C; len &#x26;&#x26; !(k in o)) {\n          k++;\n        }\n\n        // 3. If len is 0 and initialValue is not present,\n        //    throw a TypeError exception.\n        if (k >= len) {\n          throw new TypeError( 'Reduce of empty array ' +\n            'with no initial value' );\n        }\n        value = o[k++];\n      }\n\n      // 8. Repeat, while k &#x3C; len\n      while (k &#x3C; len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kPresent be ? HasProperty(O, Pk).\n        // c. If kPresent is true, then\n        //    i.  Let kValue be ? Get(O, Pk).\n        //    ii. Let accumulator be ? Call(\n        //          callbackfn, undefined,\n        //          Â« accumulator, kValue, k, O Â»).\n        if (k in o) {\n          value = callback(value, o[k], k, o);\n        }\n\n        // d. Increase k by 1.\n        k++;\n      }\n\n      // 9. Return accumulator.\n      return value;\n    }\n  });\n}\n</code></pre>\n<p><strong>Note:</strong> If you need to support truly obsolete JavaScript engines that do not support <a href=\"../object/defineproperty\"><code>Object.defineProperty()</code></a>, it is best not to polyfill <code>Array.prototype</code> methods at all, as you cannot make them <strong>non-enumerable</strong>.</p>\n<h2>Examples</h2>\n<h3>Sum all the values of an array</h3>\n<pre><code>let sum = [0, 1, 2, 3].reduce(function (accumulator, currentValue) {\n  return accumulator + currentValue\n}, 0)\n// sum is 6\n</code></pre>\n<p>Alternatively written with an arrow function:</p>\n<pre><code>let total = [ 0, 1, 2, 3 ].reduce(\n  ( accumulator, currentValue ) => accumulator + currentValue,\n  0\n)\n</code></pre>\n<h3>Sum of values in an object array</h3>\n<p>To sum up the values contained in an array of objects, you <strong>must</strong> supply an <code>initialValue</code>, so that each item passes through your function.</p>\n<pre><code>let initialValue = 0\nlet sum = [{x: 1}, {x: 2}, {x: 3}].reduce(function (accumulator, currentValue) {\n    return accumulator + currentValue.x\n}, initialValue)\n\nconsole.log(sum) // logs 6\n</code></pre>\n<p>Alternatively written with an arrow function:</p>\n<pre><code>let initialValue = 0\nlet sum = [{x: 1}, {x: 2}, {x: 3}].reduce(\n    (accumulator, currentValue) => accumulator + currentValue.x\n    , initialValue\n)\n\nconsole.log(sum) // logs 6\n</code></pre>\n<h3>Flatten an array of arrays</h3>\n<pre><code>let flattened = [[0, 1], [2, 3], [4, 5]].reduce(\n  function(accumulator, currentValue) {\n    return accumulator.concat(currentValue)\n  },\n  []\n)\n// flattened is [0, 1, 2, 3, 4, 5]\n</code></pre>\n<p>Alternatively written with an arrow function:</p>\n<pre><code>let flattened = [[0, 1], [2, 3], [4, 5]].reduce(\n  ( accumulator, currentValue ) => accumulator.concat(currentValue),\n  []\n)\n</code></pre>\n<h3>Counting instances of values in an object</h3>\n<pre><code>let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice']\n\nlet countedNames = names.reduce(function (allNames, name) {\n  if (name in allNames) {\n    allNames[name]++\n  }\n  else {\n    allNames[name] = 1\n  }\n  return allNames\n}, {})\n// countedNames is:\n// { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }\n</code></pre>\n<h3>Grouping objects by a property</h3>\n<pre><code>let people = [\n  { name: 'Alice', age: 21 },\n  { name: 'Max', age: 20 },\n  { name: 'Jane', age: 20 }\n];\n\nfunction groupBy(objectArray, property) {\n  return objectArray.reduce(function (acc, obj) {\n    let key = obj[property]\n    if (!acc[key]) {\n      acc[key] = []\n    }\n    acc[key].push(obj)\n    return acc\n  }, {})\n}\n\nlet groupedPeople = groupBy(people, 'age')\n// groupedPeople is:\n// {\n//   20: [\n//     { name: 'Max', age: 20 },\n//     { name: 'Jane', age: 20 }\n//   ],\n//   21: [{ name: 'Alice', age: 21 }]\n// }\n</code></pre>\n<h3>Bonding arrays contained in an array of objects using the spread operator and initialValue</h3>\n<pre><code>// friends - an array of objects\n// where object field \"books\" is a list of favorite books\nlet friends = [{\n  name: 'Anna',\n  books: ['Bible', 'Harry Potter'],\n  age: 21\n}, {\n  name: 'Bob',\n  books: ['War and peace', 'Romeo and Juliet'],\n  age: 26\n}, {\n  name: 'Alice',\n  books: ['The Lord of the Rings', 'The Shining'],\n  age: 18\n}]\n\n// allbooks - list which will contain all friends' books +\n// additional list contained in initialValue\nlet allbooks = friends.reduce(function(accumulator, currentValue) {\n  return [...accumulator, ...currentValue.books]\n}, ['Alphabet'])\n\n// allbooks = [\n//   'Alphabet', 'Bible', 'Harry Potter', 'War and peace',\n//   'Romeo and Juliet', 'The Lord of the Rings',\n//   'The Shining'\n// ]\n</code></pre>\n<h3>Remove duplicate items in an array</h3>\n<p><strong>Note:</strong> If you are using an environment compatible with <a href=\"../set\"><code>Set</code></a> and <a href=\"from\"><code>Array.from()</code></a>, you could use <code>let orderedArray = Array.from(new Set(myArray))</code> to get an array where duplicate items have been removed.</p>\n<pre><code>let myArray = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']\nlet myOrderedArray = myArray.reduce(function (accumulator, currentValue) {\n  if (accumulator.indexOf(currentValue) === -1) {\n    accumulator.push(currentValue)\n  }\n  return accumulator\n}, [])\n\nconsole.log(myOrderedArray)\n</code></pre>\n<h3>Replace .filter().map() with .reduce()</h3>\n<p>Using <a href=\"filter\"><code>Array.filter()</code></a> then <a href=\"map\"><code>Array.map()</code></a> traverses the array twice, but you can achieve the same effect while traversing only once with <a href=\"reduce\"><code>Array.reduce()</code></a>, thereby being more efficient. (If you like for loops, you can filter and map while traversing once with <a href=\"foreach\"><code>Array.forEach()</code></a>).</p>\n<pre><code>const numbers = [-5, 6, 2, 0,];\n\nconst doubledPositiveNumbers = numbers.reduce((accumulator, currentValue) => {\n  if (currentValue > 0) {\n    const doubled = currentValue * 2;\n    accumulator.push(doubled);\n  }\n  return accumulator;\n}, []);\n\nconsole.log(doubledPositiveNumbers); // [12, 4]\n</code></pre>\n<h3>Running Promises in Sequence</h3>\n<pre><code>/**\n * Runs promises from array of functions that can return promises\n * in chained manner\n *\n * @param {array} arr - promise arr\n * @return {Object} promise object\n */\nfunction runPromiseInSequence(arr, input) {\n  return arr.reduce(\n    (promiseChain, currentFunction) => promiseChain.then(currentFunction),\n    Promise.resolve(input)\n  )\n}\n\n// promise function 1\nfunction p1(a) {\n  return new Promise((resolve, reject) => {\n    resolve(a * 5)\n  })\n}\n\n// promise function 2\nfunction p2(a) {\n  return new Promise((resolve, reject) => {\n    resolve(a * 2)\n  })\n}\n\n// function 3  - will be wrapped in a resolved promise by .then()\nfunction f3(a) {\n return a * 3\n}\n\n// promise function 4\nfunction p4(a) {\n  return new Promise((resolve, reject) => {\n    resolve(a * 4)\n  })\n}\n\nconst promiseArr = [p1, p2, f3, p4]\nrunPromiseInSequence(promiseArr, 10)\n  .then(console.log)   // 1200\n</code></pre>\n<h3>Function composition enabling piping</h3>\n<pre><code>// Building-blocks to use for composition\nconst double = x => x + x\nconst triple = x => 3 * x\nconst quadruple = x => 4 * x\n\n// Function composition enabling pipe functionality\nconst pipe = (...functions) => input => functions.reduce(\n    (acc, fn) => fn(acc),\n    input\n)\n\n// Composed functions for multiplication of specific values\nconst multiply6 = pipe(double, triple)\nconst multiply9 = pipe(triple, triple)\nconst multiply16 = pipe(quadruple, quadruple)\nconst multiply24 = pipe(double, triple, quadruple)\n\n// Usage\nmultiply6(6)   // 36\nmultiply9(9)   // 81\nmultiply16(16) // 256\nmultiply24(10) // 240\n</code></pre>\n<h3>Write map using reduce</h3>\n<pre><code>if (!Array.prototype.mapUsingReduce) {\n  Array.prototype.mapUsingReduce = function(callback, initialValue) {\n    return this.reduce(function(mappedArray, currentValue, index, array) {\n      mappedArray[index] = callback.call(initialValue, currentValue, index, array)\n      return mappedArray\n    }, [])\n  }\n}\n\n[1, 2, , 3].mapUsingReduce(\n  (currentValue, index, array) => currentValue + index + array.length\n) // [5, 7, , 10]\n</code></pre>"}