{"expireTime":9007200904342771000,"key":"transformer-remark-markdown-html-0811edbb00c6e7058eda05b2181f9dc0--","val":"<h2><a href=\"https://leetcode.com/problems/median-of-two-sorted-arrays/description/\">4. Median of Two Sorted Arrays</a></h2>\n<h3>Problem:</h3>\n<p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>\n<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>\n<p>Example 1:</p>\n<pre><code>nums1 = [1, 3]\nnums2 = [2]\n\nThe median is 2.0\n</code></pre>\n<p>Example 2:</p>\n<pre><code>nums1 = [1, 2]\nnums2 = [3, 4]\n\nThe median is (2 + 3)/2 = 2.5\n</code></pre>\n<h3>Solution:</h3>\n<p>O(log (m+n)) means half of the sequence is ruled out on each loop. So obviously we need binary search.</p>\n<p>To do it on two sorted arrays, we need a formula to guide division.</p>\n<p>Let <code>nums3</code> be the sorted array combining all the items in <code>nums1</code> and <code>nums2</code>.</p>\n<p>If <code>nums2[j-1] &#x3C;= nums1[i] &#x3C;= nums2[j]</code>, then we know <code>nums1[i]</code> is at <code>num3[i+j]</code>. Same goes <code>nums1[i-1] &#x3C;= nums2[j] &#x3C;= nums1[i]</code>.</p>\n<p>Let <code>k</code> be <code>⌊(m+n-1)/2⌋</code>. We need to find <code>nums3[k]</code> (and also <code>nums3[k+1]</code> if m+n is even).</p>\n<p>Let <code>i + j = k</code>, if we find <code>nums2[j-1] &#x3C;= nums1[i] &#x3C;= nums2[j]</code> or <code>nums1[i-1] &#x3C;= nums2[j] &#x3C;= nums1[i]</code>, then we got <code>k</code>.</p>\n<p>Otherwise, if <code>nums1[i] &#x3C;= nums2[j]</code> then we know <code>nums1[i] &#x3C; nums2[j-1]</code> (because we did not find <code>k</code>).</p>\n<ul>\n<li>There are <code>i</code> items before <code>nums1[i]</code>, and <code>j-1</code> items brefor <code>nums2[j-1]</code>, which means <code>nums1[0...i]</code> are before <code>nums3[i+j-1]</code>. So we now know <code>nums1[0...i] &#x3C; nums3[k]</code>. They can be safely discarded.</li>\n<li></li>\n<li>We Also have <code>nums1[i] &#x3C; nums2[j]</code>, which means <code>nums2[j...n)</code> are after <code>nums3[i+j]</code>. So <code>nums2[j...n) > nums3[k]</code>.</li>\n</ul>\n<p>Same goes <code>nums1[i-1] &#x3C;= nums2[j] &#x3C;= nums1[i]</code>.</p>\n<pre><code class=\"language-js\">/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nlet findMedianSortedArrays = function (nums1, nums2) {\n    const mid = ((nums1.length + nums2.length - 1) / 2) | 0;\n\n    if ((nums1.length + nums2.length) % 2 === 0) {\n        return (_find(nums1, nums2, mid) + _find(nums1, nums2, mid + 1)) / 2;\n    }\n\n    return _find(nums1, nums2, mid);\n};\n\nfunction _find(nums1, nums2, k) {\n    if (nums1.length > nums2.length) {\n        // So that the `i` below is always smalller than k,\n        // which makes `j` always non-negative\n        [nums1, nums2] = [nums2, nums1];\n    }\n    let s1 = 0;\n    let s2 = 0;\n    let e1 = nums1.length;\n    let e2 = nums2.length;\n\n    while (s1 &#x3C; e1 || s2 &#x3C; e2) {\n        const i = s1 + (((e1 - s1) / 2) | 0);\n        const j = k - i;\n        const ni = i >= e1 ? Infinity : nums1[i];\n        const nj = j >= e2 ? Infinity : nums2[j];\n        const ni_1 = i &#x3C;= 0 ? -Infinity : nums1[i - 1];\n        const nj_1 = j &#x3C;= 0 ? -Infinity : nums2[j - 1];\n\n        if (nj_1 &#x3C;= ni &#x26;&#x26; ni &#x3C;= nj) {\n            return ni;\n        }\n\n        if (ni_1 &#x3C;= nj &#x26;&#x26; nj &#x3C;= ni) {\n            return nj;\n        }\n\n        if (ni &#x3C;= nj) {\n            s1 = i + 1;\n            e2 = j;\n        } else {\n            s2 = j + 1;\n            e1 = i;\n        }\n    }\n}\n</code></pre>\n<hr>\n<hr>\n<hr>\n<p>☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆</p>\n<hr>"}