{"expireTime":9007200904342771000,"key":"transformer-remark-markdown-html-5f7ff5ce2c811bedb62b667009b3237b--","val":"<h1>this</h1>\n<p>A <code>this</code> behaves a little differently in JavaScript compared to other languages. It also has some differences between <a href=\"../strict_mode\">strict mode</a> and non-strict mode.</p>\n<p>In most cases, the value of <code>this</code> is determined by how a function is called (runtime binding). It can't be set by assignment during execution, and it may be different each time the function is called. ES5 introduced the <a href=\"../global_objects/function/bind\"><code>bind()</code></a> method to <a href=\"#The_bind_method\">set the value of a function's <code>this</code> regardless of how it's called</a>, and ES2015 introduced <a href=\"../functions/arrow_functions\">arrow functions</a> which don't provide their own <code>this</code> binding (it retains the <code>this</code> value of the enclosing lexical context).</p>\n<h2>Syntax</h2>\n<pre><code>this\n</code></pre>\n<h3>Value</h3>\n<p>A property of an execution context (global, function or eval) that, in non-strict mode, is always a reference to an object and in strict mode can be any value.</p>\n<h2>Description</h2>\n<h3>Global context</h3>\n<p>In the global execution context (outside of any function), <code>this</code> refers to the global object whether in strict mode or not.</p>\n<pre><code>// In web browsers, the window object is also the global object:\nconsole.log(this === window); // true\n\na = 37;\nconsole.log(window.a); // 37\n\nthis.b = \"MDN\";\nconsole.log(window.b)  // \"MDN\"\nconsole.log(b)         // \"MDN\"\n</code></pre>\n<p><strong>Note:</strong> You can always easily get the global object using the global <a href=\"../global_objects/globalthis\"><code>globalThis</code></a> property, regardless of the current context in which your code is running.</p>\n<h3>Function context</h3>\n<p>Inside a function, the value of <code>this</code> depends on how the function is called.</p>\n<p>Since the following code is not in <a href=\"../strict_mode\">strict mode</a>, and because the value of <code>this</code> is not set by the call, <code>this</code> will default to the global object, which is <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window\"><code>window</code></a> in a browser.</p>\n<pre><code>function f1() {\n  return this;\n}\n\n// In a browser:\nf1() === window; // true\n\n// In Node:\nf1() === globalThis; // true\n</code></pre>\n<p>In strict mode, however, if the value of <code>this</code> is not set when entering an execution context, it remains as <code>undefined</code>, as shown in the following example:</p>\n<pre><code>function f2() {\n  'use strict'; // see strict mode\n  return this;\n}\n\nf2() === undefined; // true\n</code></pre>\n<p><strong>Note:</strong> In the second example, <code>this</code> should be <a href=\"../global_objects/undefined\"><code>undefined</code></a>, because <code>f2</code> was called directly and not as a method or property of an object (e.g. <code>window.f2()</code>). This feature wasn't implemented in some browsers when they first started to support <a href=\"../strict_mode\">strict mode</a>. As a result, they incorrectly returned the <code>window</code> object.</p>\n<p>To set the value of <code>this</code> to a particular value when calling a function, use <a href=\"../global_objects/function/call\"><code>call()</code></a>, or <a href=\"../global_objects/function/apply\"><code>apply()</code></a> as in the examples below.</p>\n<h3>Class context</h3>\n<p>The behavior of <code>this</code> in <a href=\"../classes\">classes</a> and functions is similar, since classes are functions under the hood. But there are some differences and caveats.</p>\n<p>Within a class constructor, <code>this</code> is a regular object. All non-static methods within the class are added to the prototype of <code>this</code>:</p>\n<pre><code>class Example {\n  constructor() {\n    const proto = Object.getPrototypeOf(this);\n    console.log(Object.getOwnPropertyNames(proto));\n  }\n  first(){}\n  second(){}\n  static third(){}\n}\n\nnew Example(); // ['constructor', 'first', 'second']\n</code></pre>\n<p><strong>Note:</strong> Static methods are not properties of <code>this</code>. They are properties of the class itself.</p>\n<h3>Derived classes</h3>\n<p>Unlike base class constructors, derived constructors have no initial <code>this</code> binding. Calling <a href=\"super\"><code>super()</code></a> creates a <code>this</code> binding within the constructor and essentially has the effect of evaluating the following line of code, where Base is the inherited class:</p>\n<pre><code>this = new Base();\n</code></pre>\n<p><strong>Warning:</strong> Referring to <code>this</code> before calling <code>super()</code> will throw an error.</p>\n<p>Derived classes must not return before calling <code>super()</code>, unless they return an <code>Object</code> or have no constructor at all.</p>\n<pre><code>class Base {}\nclass Good extends Base {}\nclass AlsoGood extends Base {\n  constructor() {\n    return {a: 5};\n  }\n}\nclass Bad extends Base {\n  constructor() {}\n}\n\nnew Good();\nnew AlsoGood();\nnew Bad(); // ReferenceError\n</code></pre>\n<h2>Examples</h2>\n<h3>this in function contexts</h3>\n<pre><code>// An object can be passed as the first argument to call or apply and this will be bound to it.\nvar obj = {a: 'Custom'};\n\n// We declare a variable and the variable is assigned to the global window as its property.\nvar a = 'Global';\n\nfunction whatsThis() {\n  return this.a;  // The value of this is dependent on how the function is called\n}\n\nwhatsThis();          // 'Global' as this in the function isn't set, so it defaults to the global/window object\nwhatsThis.call(obj);  // 'Custom' as this in the function is set to obj\nwhatsThis.apply(obj); // 'Custom' as this in the function is set to obj\n</code></pre>\n<h3>this and object conversion</h3>\n<pre><code>function add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nvar o = {a: 1, b: 3};\n\n// The first parameter is the object to use as\n// 'this', subsequent parameters are passed as\n// arguments in the function call\nadd.call(o, 5, 7); // 16\n\n// The first parameter is the object to use as\n// 'this', the second is an array whose\n// members are used as the arguments in the function call\nadd.apply(o, [10, 20]); // 34\n</code></pre>\n<p>Note that in non-strict mode, with <code>call</code> and <code>apply</code>, if the value passed as <code>this</code> is not an object, an attempt will be made to convert it to an object. Values <code>null</code> and <code>undefined</code> become the global object. Primitives like <code>7</code> or <code>'foo'</code> will be converted to an Object using the related constructor, so the primitive number <code>7</code> is converted to an object as if by <code>new Number(7)</code> and the string <code>'foo'</code> to an object as if by <code>new String('foo')</code>, e.g.</p>\n<pre><code>function bar() {\n  console.log(Object.prototype.toString.call(this));\n}\n\nbar.call(7);     // [object Number]\nbar.call('foo'); // [object String]\nbar.call(undefined); // [object global]\n</code></pre>\n<h3>The <code>bind</code> method</h3>\n<p>ECMAScript 5 introduced <a href=\"../global_objects/function/bind\"><code>Function.prototype.bind()</code></a>. Calling <code>f.bind(someObject)</code> creates a new function with the same body and scope as <code>f</code>, but where <code>this</code> occurs in the original function, in the new function it is permanently bound to the first argument of <code>bind</code>, regardless of how the function is being used.</p>\n<pre><code>function f() {\n  return this.a;\n}\n\nvar g = f.bind({a: 'azerty'});\nconsole.log(g()); // azerty\n\nvar h = g.bind({a: 'yoo'}); // bind only works once!\nconsole.log(h()); // azerty\n\nvar o = {a: 37, f: f, g: g, h: h};\nconsole.log(o.a, o.f(), o.g(), o.h()); // 37,37, azerty, azerty\n</code></pre>\n<h3>Arrow functions</h3>\n<p>In <a href=\"../functions/arrow_functions\">arrow functions</a>, <code>this</code> retains the value of the enclosing lexical context's <code>this</code>. In global code, it will be set to the global object:</p>\n<pre><code>var globalObject = this;\nvar foo = (() => this);\nconsole.log(foo() === globalObject); // true\n</code></pre>\n<p><strong>Note:</strong> If <code>this</code> arg is passed to <code>call</code>, <code>bind</code>, or <code>apply</code> on invocation of an arrow function it will be ignored. You can still prepend arguments to the call, but the first argument (<code>thisArg</code>) should be set to <code>null</code>.</p>\n<pre><code>// Call as a method of an object\nvar obj = {func: foo};\nconsole.log(obj.func() === globalObject); // true\n\n// Attempt to set this using call\nconsole.log(foo.call(obj) === globalObject); // true\n\n// Attempt to set this using bind\nfoo = foo.bind(obj);\nconsole.log(foo() === globalObject); // true\n</code></pre>\n<p>No matter what, <code>foo</code>'s <code>this</code> is set to what it was when it was created (in the example above, the global object). The same applies to arrow functions created inside other functions: their <code>this</code> remains that of the enclosing lexical context.</p>\n<pre><code>// Create obj with a method bar that returns a function that\n// returns its this. The returned function is created as\n// an arrow function, so its this is permanently bound to the\n// this of its enclosing function. The value of bar can be set\n// in the call, which in turn sets the value of the\n// returned function.\nvar obj = {\n  bar: function() {\n    var x = (() => this);\n    return x;\n  }\n};\n\n// Call bar as a method of obj, setting its this to obj\n// Assign a reference to the returned function to fn\nvar fn = obj.bar();\n\n// Call fn without setting this, would normally default\n// to the global object or undefined in strict mode\nconsole.log(fn() === obj); // true\n\n// But caution if you reference the method of obj without calling it\nvar fn2 = obj.bar;\n// Calling the arrow function's this from inside the bar method()\n// will now return window, because it follows the this from fn2.\nconsole.log(fn2()() == window); // true\n</code></pre>\n<p>In the above, the function (call it anonymous function A) assigned to <code>obj.bar</code> returns another function (call it anonymous function B) that is created as an arrow function. As a result, function B's <code>this</code> is permanently set to the <code>this</code> of <code>obj.bar</code> (function A) when called. When the returned function (function B) is called, its <code>this</code> will always be what it was set to initially. In the above code example, function B's <code>this</code> is set to function A's <code>this</code> which is <code>obj</code>, so it remains set to <code>obj</code> even when called in a manner that would normally set its <code>this</code> to <code>undefined</code> or the global object (or any other method as in the previous example in the global execution context).</p>\n<h3>As an object method</h3>\n<p>When a function is called as a method of an object, its <code>this</code> is set to the object the method is called on.</p>\n<p>In the following example, when <code>o.f()</code> is invoked, inside the function <code>this</code> is bound to the <code>o</code> object.</p>\n<pre><code>var o = {\n  prop: 37,\n  f: function() {\n    return this.prop;\n  }\n};\n\nconsole.log(o.f()); // 37\n</code></pre>\n<p>Note that this behavior is not at all affected by how or where the function was defined. In the previous example, we defined the function inline as the <code>f</code> member during the definition of <code>o</code>. However, we could have just as easily defined the function first and later attached it to <code>o.f</code>. Doing so results in the same behavior:</p>\n<pre><code>var o = {prop: 37};\n\nfunction independent() {\n  return this.prop;\n}\n\no.f = independent;\n\nconsole.log(o.f()); // 37\n</code></pre>\n<p>This demonstrates that it matters only that the function was invoked from the <code>f</code> member of <code>o</code>.</p>\n<p>Similarly, the <code>this</code> binding is only affected by the most immediate member reference. In the following example, when we invoke the function, we call it as a method <code>g</code> of the object <code>o.b</code>. This time during execution, <code>this</code> inside the function will refer to <code>o.b</code>. The fact that the object is itself a member of <code>o</code> has no consequence; the most immediate reference is all that matters.</p>\n<pre><code>o.b = {g: independent, prop: 42};\nconsole.log(o.b.g()); // 42\n</code></pre>\n<h4><code>this</code> on the object's prototype chain</h4>\n<p>The same notion holds true for methods defined somewhere on the object's prototype chain. If the method is on an object's prototype chain, <code>this</code> refers to the object the method was called on, as if the method were on the object.</p>\n<pre><code>var o = {f: function() { return this.a + this.b; }};\nvar p = Object.create(o);\np.a = 1;\np.b = 4;\n\nconsole.log(p.f()); // 5\n</code></pre>\n<p>In this example, the object assigned to the variable <code>p</code> doesn't have its own <code>f</code> property, it inherits it from its prototype. But it doesn't matter that the lookup for <code>f</code> eventually finds a member with that name on <code>o</code>; the lookup began as a reference to <code>p.f</code>, so <code>this</code> inside the function takes the value of the object referred to as <code>p</code>. That is, since <code>f</code> is called as a method of <code>p</code>, its <code>this</code> refers to <code>p</code>. This is an interesting feature of JavaScript's prototype inheritance.</p>\n<h4><code>this</code> with a getter or setter</h4>\n<p>Again, the same notion holds true when a function is invoked from a getter or a setter. A function used as getter or setter has its <code>this</code> bound to the object from which the property is being set or gotten.</p>\n<pre><code>function sum() {\n  return this.a + this.b + this.c;\n}\n\nvar o = {\n  a: 1,\n  b: 2,\n  c: 3,\n  get average() {\n    return (this.a + this.b + this.c) / 3;\n  }\n};\n\nObject.defineProperty(o, 'sum', {\n    get: sum, enumerable: true, configurable: true});\n\nconsole.log(o.average, o.sum); // 2, 6\n</code></pre>\n<h3>As a constructor</h3>\n<p>When a function is used as a constructor (with the <a href=\"new\"><code>new</code></a> keyword), its <code>this</code> is bound to the new object being constructed.</p>\n<p><strong>Note:</strong> While the default for a constructor is to return the object referenced by <code>this</code>, it can instead return some other object (if the return value isn't an object, then the <code>this</code> object is returned).</p>\n<pre><code>/*\n * Constructors work like this:\n *\n * function MyConstructor(){\n *   // Actual function body code goes here.\n *   // Create properties on |this| as\n *   // desired by assigning to them.  E.g.,\n *   this.fum = \"nom\";\n *   // et cetera...\n *\n *   // If the function has a return statement that\n *   // returns an object, that object will be the\n *   // result of the |new| expression.  Otherwise,\n *   // the result of the expression is the object\n *   // currently bound to |this|\n *   // (i.e., the common case most usually seen).\n * }\n */\n\nfunction C() {\n  this.a = 37;\n}\n\nvar o = new C();\nconsole.log(o.a); // 37\n\nfunction C2() {\n  this.a = 37;\n  return {a: 38};\n}\n\no = new C2();\nconsole.log(o.a); // 38\n</code></pre>\n<p>In the last example (<code>C2</code>), because an object was returned during construction, the new object that <code>this</code> was bound to gets discarded. (This essentially makes the statement \"<code>this.a = 37;</code>\" dead code. It's not exactly dead because it gets executed, but it can be eliminated with no outside effects.)</p>\n<h3>As a DOM event handler</h3>\n<p>When a function is used as an event handler, its <code>this</code> is set to the element on which the listener is placed (some browsers do not follow this convention for listeners added dynamically with methods other than <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\"><code>addEventListener()</code></a>).</p>\n<pre><code>// When called as a listener, turns the related element blue\nfunction bluify(e) {\n  // Always true\n  console.log(this === e.currentTarget);\n  // true when currentTarget and target are the same object\n  console.log(this === e.target);\n  this.style.backgroundColor = '#A5D9F3';\n}\n\n// Get a list of every element in the document\nvar elements = document.getElementsByTagName('*');\n\n// Add bluify as a click listener so when the\n// element is clicked on, it turns blue\nfor (var i = 0; i &#x3C; elements.length; i++) {\n  elements[i].addEventListener('click', bluify, false);\n}\n</code></pre>\n<h3>In an inline event handler</h3>\n<p>When the code is called from an inline <a href=\"https://developer.mozilla.org/en-US/docs/Web/Events/Event_handlers\">on-event handler</a>, its <code>this</code> is set to the DOM element on which the listener is placed:</p>\n<pre><code>&#x3C;button onclick=\"alert(this.tagName.toLowerCase());\">\n  Show this\n&#x3C;/button>\n</code></pre>\n<p>The above alert shows <code>button</code>. Note however that only the outer code has its <code>this</code> set this way:</p>\n<pre><code>&#x3C;button onclick=\"alert((function() { return this; })());\">\n  Show inner this\n&#x3C;/button>\n</code></pre>\n<p>In this case, the inner function's <code>this</code> isn't set so it returns the global/window object (i.e. the default object in non-strict mode where <code>this</code> isn't set by the call).</p>\n<h3>this in classes</h3>\n<p>Just like with regular functions, the value of <code>this</code> within methods depends on how they are called. Sometimes it is useful to override this behavior so that <code>this</code> within classes always refers to the class instance. To achieve this, bind the class methods in the constructor:</p>\n<pre><code>class Car {\n  constructor() {\n    // Bind sayBye but not sayHi to show the difference\n    this.sayBye = this.sayBye.bind(this);\n  }\n  sayHi() {\n    console.log(`Hello from ${this.name}`);\n  }\n  sayBye() {\n    console.log(`Bye from ${this.name}`);\n  }\n  get name() {\n    return 'Ferrari';\n  }\n}\n\nclass Bird {\n  get name() {\n    return 'Tweety';\n  }\n}\n\nconst car = new Car();\nconst bird = new Bird();\n\n// The value of 'this' in methods depends on their caller\ncar.sayHi(); // Hello from Ferrari\nbird.sayHi = car.sayHi;\nbird.sayHi(); // Hello from Tweety\n\n// For bound methods, 'this' doesn't depend on the caller\nbird.sayBye = car.sayBye;\nbird.sayBye();  // Bye from Ferrari\n</code></pre>\n<p><strong>Note:</strong> Classes are always strict mode code. Calling methods with an undefined <code>this</code> will throw an error.</p>"}