{"expireTime":9007200904342771000,"key":"transformer-remark-markdown-html-3a22668f9f7d79a933ecb765d52dcc26--","val":"<h2>What is a buffer?</h2>\n<p>A buffer is an area of memory. JavaScript developers are not familiar with this concept, much less than C, C++ or Go developers (or any programmer that uses a system programming language), which interact with memory every day.</p>\n<p>It represents a fixed-size chunk of memory (can't be resized) allocated outside of the V8 JavaScript engine.</p>\n<p>You can think of a buffer like an array of integers, which each represent a byte of data.</p>\n<p>It is implemented by the Node.js <a href=\"https://nodejs.org/api/buffer.html\">Buffer class</a>.</p>\n<h2>Why do we need a buffer?</h2>\n<p>Buffers were introduced to help developers deal with binary data, in an ecosystem that traditionally only dealt with strings rather than binaries.</p>\n<p>Buffers are deeply linked with streams. When a stream processor receives data faster than it can digest, it puts the data in a buffer.</p>\n<p>A simple visualization of a buffer is when you are watching a YouTube video and the red line goes beyond your visualization point: you are downloading data faster than you're viewing it, and your browser buffers it.</p>\n<h2>How to create a buffer</h2>\n<p>A buffer is created using the <a href=\"https://nodejs.org/api/buffer.html#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe\"><code>Buffer.from()</code></a>, <a href=\"https://nodejs.org/api/buffer.html#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a>, and <a href=\"https://nodejs.org/api/buffer.html#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> methods.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('Hey!');\n</code></pre>\n<ul>\n<li><a href=\"https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_array\"><code>Buffer.from(array)</code></a></li>\n<li><a href=\"https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a></li>\n<li><a href=\"https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_buffer\"><code>Buffer.from(buffer)</code></a></li>\n<li><a href=\"https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a></li>\n</ul>\n<p>You can also just initialize the buffer passing the size. This creates a 1KB buffer:</p>\n<pre><code class=\"language-js\">const buf = Buffer.alloc(1024);\n//or\nconst buf = Buffer.allocUnsafe(1024);\n</code></pre>\n<p>While both <code>alloc</code> and <code>allocUnsafe</code> allocate a <code>Buffer</code> of the specified size in bytes, the <code>Buffer</code> created by <code>alloc</code> will be <em>initialized</em> with zeroes and the one created by <code>allocUnsafe</code> will be <em>uninitialized</em>. This means that while <code>allocUnsafe</code> would be quite fast in comparison to <code>alloc</code>, the allocated segment of memory may contain old data which could potentially be sensitive.</p>\n<p>Older data, if present in the memory, can be accessed or leaked when the <code>Buffer</code> memory is read. This is what really makes <code>allocUnsafe</code> unsafe and extra care must be taken while using it.</p>\n<h2>Using a buffer</h2>\n<h3>Access the content of a buffer</h3>\n<p>A buffer, being an array of bytes, can be accessed like an array:</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('Hey!');\nconsole.log(buf[0]); //72\nconsole.log(buf[1]); //101\nconsole.log(buf[2]); //121\n</code></pre>\n<p>Those numbers are the Unicode Code that identifies the character in the buffer position (H => 72, e => 101, y => 121)</p>\n<p>You can print the full content of the buffer using the <code>toString()</code> method:</p>\n<pre><code class=\"language-js\">console.log(buf.toString());\n</code></pre>\n<blockquote>\n<p>Notice that if you initialize a buffer with a number that sets its size, you'll get access to pre-initialized memory that will contain random data, not an empty buffer!</p>\n</blockquote>\n<h3>Get the length of a buffer</h3>\n<p>Use the <code>length</code> property:</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('Hey!');\nconsole.log(buf.length);\n</code></pre>\n<h3>Iterate over the contents of a buffer</h3>\n<pre><code class=\"language-js\">const buf = Buffer.from('Hey!');\nfor (const item of buf) {\n    console.log(item); //72 101 121 33\n}\n</code></pre>\n<h3>Changing the content of a buffer</h3>\n<p>You can write to a buffer a whole string of data by using the <code>write()</code> method:</p>\n<pre><code class=\"language-js\">const buf = Buffer.alloc(4);\nbuf.write('Hey!');\n</code></pre>\n<p>Just like you can access a buffer with an array syntax, you can also set the contents of the buffer in the same way:</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('Hey!');\nbuf[1] = 111; //o\nconsole.log(buf.toString()); //Hoy!\n</code></pre>\n<h3>Copy a buffer</h3>\n<p>Copying a buffer is possible using the <code>copy()</code> method:</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('Hey!');\nlet bufcopy = Buffer.alloc(4); //allocate 4 bytes\nbuf.copy(bufcopy);\n</code></pre>\n<p>By default you copy the whole buffer. 3 more parameters let you define the starting position, the ending position, and the new buffer length:</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('Hey!');\nlet bufcopy = Buffer.alloc(2); //allocate 2 bytes\nbuf.copy(bufcopy, 0, 0, 2);\nbufcopy.toString(); //'He'\n</code></pre>\n<h3>Slice a buffer</h3>\n<p>If you want to create a partial visualization of a buffer, you can create a slice. A slice is not a copy: the original buffer is still the source of truth. If that changes, your slice changes.</p>\n<p>Use the <code>slice()</code> method to create it. The first parameter is the starting position, and you can specify an optional second parameter with the end position:</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('Hey!');\nbuf.slice(0).toString(); //Hey!\nconst slice = buf.slice(0, 2);\nconsole.log(slice.toString()); //He\nbuf[1] = 111; //o\nconsole.log(slice.toString()); //Ho\n</code></pre>"}