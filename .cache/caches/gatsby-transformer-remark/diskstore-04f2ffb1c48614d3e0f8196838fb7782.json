{"expireTime":9007200904342771000,"key":"transformer-remark-markdown-html-f194c02cc22eabb5f89ecf253a484389--","val":"<h2><a href=\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/\">17. Letter Combinations of a Phone Number</a></h2>\n<h3>Problem:</h3>\n<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.</p>\n<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png\" alt=\"200px-Telephone-keypad2\"></p>\n<p><strong>Example:</strong></p>\n<pre><code>Input: \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n</code></pre>\n<p><strong>Note:</strong></p>\n<p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>\n<h3>Solution:</h3>\n<h4>ONE</h4>\n<p>JavaScript specific optimization.</p>\n<p><code>Array.prototype.push</code> accepts arbitrary arguments which enables tighter loops.</p>\n<p>Also, appending string is faster than prepending.</p>\n<pre><code class=\"language-js\">/**\n * @param {string} digits\n * @return {string[]}\n */\nlet letterCombinations = function (digits) {\n    if (digits.length &#x3C;= 0) {\n        return [];\n    }\n\n    const letters = [\n        ,\n        ,\n        ['a', 'b', 'c'],\n        ['d', 'e', 'f'],\n        ['g', 'h', 'i'],\n        ['j', 'k', 'l'],\n        ['m', 'n', 'o'],\n        ['p', 'q', 'r', 's'],\n        ['t', 'u', 'v'],\n        ['w', 'x', 'y', 'z']\n    ];\n\n    let result = [''];\n\n    for (let i = 0; i &#x3C; digits.length; i++) {\n        const arr = letters[digits[i]];\n        let newResult = [];\n        arr.forEach((c) => newResult.push(...result.map((r) => r + c)));\n        result = newResult;\n    }\n\n    return result;\n};\n</code></pre>\n<h4>TWO</h4>\n<p>General recursive DFS solution.</p>\n<pre><code class=\"language-js\">/**\n * @param {string} digits\n * @return {string[]}\n */\nlet letterCombinations = function (digits) {\n    const letters = [, , 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];\n    const result = [];\n    if (digits.length > 0) {\n        dfs(digits, 0, '', letters, result);\n    }\n    return result;\n};\n\nfunction dfs(digits, idigit, path, letters, result) {\n    if (idigit >= digits.length) {\n        result.push(path);\n        return;\n    }\n    const str = letters[digits[idigit]];\n    for (let i = 0; i &#x3C; str.length; i++) {\n        dfs(digits, idigit + 1, path + str[i], letters, result);\n    }\n}\n</code></pre>\n<hr>\n<p>☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆</p>\n<hr>\n<hr>\n<p>☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆</p>\n<hr>"}