{"expireTime":9007200904342771000,"key":"transformer-remark-markdown-html-9b798af4d6b47f53b51d24e56f4d4783--","val":"<h2><a href=\"https://leetcode.com/problems/generate-parentheses/description/\">22. Generate Parentheses</a></h2>\n<h3>Problem:</h3>\n<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>\n<p>For example, given n = 3, a solution set is:</p>\n<pre><code>[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n</code></pre>\n<h3>Solution:</h3>\n<h4>ONE</h4>\n<p>Recursive DFS backtracking.</p>\n<pre><code class=\"language-js\">/**\n * @param {number} n\n * @return {string[]}\n */\nlet generateParenthesis = function (n) {\n    const result = [];\n    if (n > 0) {\n        dfs(n, 0, 0, '', result);\n    }\n    return result;\n};\n\nfunction dfs(n, nopen, nclose, path, result) {\n    if (path.length === n * 2) {\n        result.push(path);\n        return;\n    }\n\n    if (nopen &#x3C; n) {\n        dfs(n, nopen + 1, nclose, path + '(', result);\n    }\n\n    if (nclose &#x3C; nopen) {\n        dfs(n, nopen, nclose + 1, path + ')', result);\n    }\n}\n</code></pre>\n<h4>TWO</h4>\n<p>BFS.</p>\n<pre><code class=\"language-js\">/**\n * @param {number} n\n * @return {string[]}\n */\nlet generateParenthesis = function (n) {\n    if (n &#x3C;= 0) {\n        return [];\n    }\n\n    const queue = [\n        {\n            path: '(',\n            open: 1,\n            close: 0\n        }\n    ];\n\n    while (true) {\n        const { path, open, close } = queue.shift();\n        if (open + close === n * 2) {\n            queue.unshift({ path, open, close });\n            break;\n        }\n\n        if (open &#x3C; n) {\n            queue.push({\n                path: path + '(',\n                open: open + 1,\n                close\n            });\n        }\n\n        if (close &#x3C; open) {\n            queue.push({\n                path: path + ')',\n                open,\n                close: close + 1\n            });\n        }\n    }\n\n    return queue.map((x) => x.path);\n};\n</code></pre>\n<hr>\n<p>☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆</p>\n<hr>\n<hr>\n<p>☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆</p>\n<hr>"}