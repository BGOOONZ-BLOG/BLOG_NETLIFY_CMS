{"expireTime":9007200904342772000,"key":"transformer-remark-markdown-html-bb619977265832084a668eaa7f4009b5--","val":"<details>\n<summary> Description</summary>   \n<blockquote>\n<h2>Excerpt</h2>\n<p>The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. It also provides a global fetch() method that provides an easy, logical way to fetch resources asynchronously across the network.</p>\n</blockquote>\n<hr>\n<p>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">Fetch API</a> provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. It also provides a global <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/fetch\"><code>fetch()</code></a> method that provides an easy, logical way to fetch resources asynchronously across the network.</p>\n<p>This kind of functionality was previously achieved using <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\"><code>XMLHttpRequest</code></a>. Fetch provides a better alternative that can be easily used by other technologies such as <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\" title=\"Service Workers\"><code>Service Workers</code></a>. Fetch also provides a single logical place to define other HTTP-related concepts such as <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\">CORS</a> and extensions to HTTP.</p>\n<p>The <code>fetch</code> specification differs from <code>jQuery.ajax()</code> in the following significant ways:</p>\n<ul>\n<li>The Promise returned from <code>fetch()</code> <strong>won't reject on HTTP error status</strong> even if the response is an HTTP 404 or 500. Instead, as soon as the server responds with headers, the Promise will resolve normally (with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response/ok\" title=\"ok\"><code>ok</code></a> property of the response set to false if the response isn't in the range 200 -299), and it will only reject on network failure or if anything prevented the request from completing.</li>\n<li><code>fetch()</code> <strong>won't send cross-origin cookies</strong> unless you set the <em>credentials</em> <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/fetch#parameters\">init option</a>. (Since <a href=\"https://github.com/whatwg/fetch/pull/585\">April 2018</a>. The spec changed the default credentials policy to <code>same-origin</code>. Firefox changed since 61.0b13.)</li>\n</ul>\n<p>A basic fetch request is really simple to set up. Have a look at the following code:</p>\n<pre><code class=\"language-js\">fetch('http://example.com/movies.json')\n  .then(response => response.json())\n  .then(data => console.log(data));\n</code></pre>\n<p>Here we are fetching a JSON file across the network and printing it to the console. The simplest use of <code>fetch()</code> takes one argument — the path to the resource you want to fetch — and does not directly return the JSON response body but instead returns a promise that resolves with a <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response\"><code>Response</code></a> object.</p>\n<p>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response\"><code>Response</code></a> object, in turn, does not directly contain the actual JSON response body but is instead a representation of the entire HTTP response. So, to extract the JSON body content from the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response\"><code>Response</code></a> object, we use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response/json\" title=\"json()\"><code>json()</code></a> method, which returns a second promise that resolves with the result of parsing the response body text as JSON.</p>\n<p><strong>Note:</strong> See the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#body\">Body</a> section for similar methods to extract other types of body content.</p>\n<p>Fetch requests are controlled by the <code>connect-src</code> directive of <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy\">Content Security Policy</a> rather than the directive of the resources it's retrieving.</p>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#supplying_request_options\" title=\"Permalink to Supplying request options\">Supplying request options</a></h3>\n<p>The <code>fetch()</code> method can optionally accept a second parameter, an <code>init</code> object that allows you to control a number of different settings:</p>\n<p>See <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/fetch\"><code>fetch()</code></a> for the full options available, and more details.</p>\n<pre><code class=\"language-js\">js\n// Example POST method implementation:\nasync function postData(url = '', data = {}) {\n  // Default options are marked with *\n  const response = await fetch(url, {\n    method: 'POST', // *GET, POST, PUT, DELETE, etc.\n    mode: 'cors', // no-cors, *cors, same-origin\n    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached\n    credentials: 'same-origin', // include, *same-origin, omit\n    headers: {\n      'Content-Type': 'application/json'\n      // 'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    redirect: 'follow', // manual, *follow, error\n    referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url\n    body: JSON.stringify(data) // body data type must match \"Content-Type\" header\n  });\n  return response.json(); // parses JSON response into native JavaScript objects\n}\n\npostData('https://example.com/answer', { answer: 42 })\n  .then(data => {\n    console.log(data); // JSON data parsed by `data.json()` call\n  });\n</code></pre>\n<p>Note that <code>mode: \"no-cors\"</code> only allows a limited set of headers in the request:</p>\n<ul>\n<li><code>Accept</code></li>\n<li><code>Accept-Language</code></li>\n<li><code>Content-Language</code></li>\n<li><code>Content-Type</code> with a value of <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, or <code>text/plain</code></li>\n</ul>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#sending_a_request_with_credentials_included\" title=\"Permalink to Sending a request with credentials included\">Sending a request with credentials included</a></h3>\n<p>To cause browsers to send a request with credentials included on both same-origin and cross-origin calls, add <code>credentials: 'include'</code> to the <code>init</code> object you pass to the <code>fetch()</code> method.</p>\n<pre><code class=\"language-js\">fetch('https://example.com', {\n  credentials: 'include'\n});\n</code></pre>\n<p><strong>Note:</strong> <code>Access-Control-Allow-Origin</code> is prohibited from using a wildcard for requests with <code>credentials: 'include'</code>. In such cases, the exact origin must be provided; even if you are using a CORS unblocker extension, the requests will still fail.</p>\n<p><strong>Note:</strong> Browsers should not send credentials in <em>preflight requests</em> irrespective of this setting. For more information see: <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#requests_with_credentials\">CORS > Requests with credentials</a>.</p>\n<p>If you only want to send credentials if the request URL is on the same origin as the calling script, add <code>credentials: 'same-origin'</code>.</p>\n<pre><code class=\"language-js\">// The calling script is on the origin 'https://example.com'\n\nfetch('https://example.com', {\n  credentials: 'same-origin'\n});\n</code></pre>\n<p>To instead ensure browsers don't include credentials in the request, use <code>credentials: 'omit'</code>.</p>\n<pre><code class=\"language-js\">fetch('https://example.com', {\n  credentials: 'omit'\n})\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#uploading_json_data\" title=\"Permalink to Uploading JSON data\">Uploading JSON data</a></h3>\n<p>Use <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/fetch\"><code>fetch()</code></a> to POST JSON-encoded data.</p>\n<pre><code class=\"language-js\">const data = { username: 'example' };\n\nfetch('https://example.com/profile', {\n  method: 'POST', // or 'PUT'\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify(data),\n})\n.then(response => response.json())\n.then(data => {\n  console.log('Success:', data);\n})\n.catch((error) => {\n  console.error('Error:', error);\n});\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#uploading_a_file\" title=\"Permalink to Uploading a file\">Uploading a file</a></h3>\n<p>Files can be uploaded using an HTML <code>&#x3C;input type=\"file\" /></code> input element, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData\" title=\"FormData()\"><code>FormData()</code></a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/fetch\"><code>fetch()</code></a>.</p>\n<pre><code class=\"language-js\">const formData = new FormData();\nconst fileField = document.querySelector('input[type=\"file\"]');\n\nformData.append('username', 'abc123');\nformData.append('avatar', fileField.files[0]);\n\nfetch('https://example.com/profile/avatar', {\n  method: 'PUT',\n  body: formData\n})\n.then(response => response.json())\n.then(result => {\n  console.log('Success:', result);\n})\n.catch(error => {\n  console.error('Error:', error);\n});\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#uploading_multiple_files\" title=\"Permalink to Uploading multiple files\">Uploading multiple files</a></h3>\n<p>Files can be uploaded using an HTML <code>&#x3C;input type=\"file\" multiple /></code> input element, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData\" title=\"FormData()\"><code>FormData()</code></a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/fetch\"><code>fetch()</code></a>.</p>\n<pre><code class=\"language-js\">const formData = new FormData();\nconst photos = document.querySelector('input[type=\"file\"][multiple]');\n\nformData.append('title', 'My Vegas Vacation');\nfor (let i = 0; i &#x3C; photos.files.length; i++) {\n  formData.append(`photos_${i}`, photos.files[i]);\n}\n\nfetch('https://example.com/posts', {\n  method: 'POST',\n  body: formData,\n})\n.then(response => response.json())\n.then(result => {\n  console.log('Success:', result);\n})\n.catch(error => {\n  console.error('Error:', error);\n});\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#processing_a_text_file_line_by_line\" title=\"Permalink to Processing a text file line by line\">Processing a text file line by line</a></h3>\n<p>The chunks that are read from a response are not broken neatly at line boundaries and are Uint8Arrays, not strings. If you want to fetch a text file and process it line by line, it is up to you to handle these complications. The following example shows one way to do this by creating a line iterator (for simplicity, it assumes the text is UTF-8, and doesn't handle fetch errors).</p>\n<pre><code class=\"language-js\">async function* makeTextFileLineIterator(fileURL) {\n  const utf8Decoder = new TextDecoder('utf-8');\n  const response = await fetch(fileURL);\n  const reader = response.body.getReader();\n  let { value: chunk, done: readerDone } = await reader.read();\n  chunk = chunk ? utf8Decoder.decode(chunk) : '';\n\n  const re = /\\n|\\r|\\r\\n/gm;\n  let startIndex = 0;\n  let result;\n\n  for (;;) {\n    let result = re.exec(chunk);\n    if (!result) {\n      if (readerDone) {\n        break;\n      }\n      let remainder = chunk.substr(startIndex);\n      ({ value: chunk, done: readerDone } = await reader.read());\n      chunk = remainder + (chunk ? utf8Decoder.decode(chunk) : '');\n      startIndex = re.lastIndex = 0;\n      continue;\n    }\n    yield chunk.substring(startIndex, result.index);\n    startIndex = re.lastIndex;\n  }\n  if (startIndex &#x3C; chunk.length) {\n    // last line didn't end in a newline char\n    yield chunk.substr(startIndex);\n  }\n}\n\nasync function run() {\n  for await (let line of makeTextFileLineIterator(urlOfFile)) {\n    processLine(line);\n  }\n}\n\nrun();\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#checking_that_the_fetch_was_successful\" title=\"Permalink to Checking that the fetch was successful\">Checking that the fetch was successful</a></h3>\n<p>A <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/fetch\"><code>fetch()</code></a> promise will reject with a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\"><code>TypeError</code></a> when a network error is encountered or CORS is misconfigured on the server-side, although this usually means permission issues or similar — a 404 does not constitute a network error, for example. An accurate check for a successful <code>fetch()</code> would include checking that the promise resolved, then checking that the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response/ok\"><code>Response.ok</code></a> property has a value of true. The code would look something like this:</p>\n<pre><code>fetch('flowers.jpg')\n  .then(response => {\n    if (!response.ok) {\n      throw new Error('Network response was not OK');\n    }\n    return response.blob();\n  })\n  .then(myBlob => {\n    myImage.src = URL.createObjectURL(myBlob);\n  })\n  .catch(error => {\n    console.error('There has been a problem with your fetch operation:', error);\n  });\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#supplying_your_own_request_object\" title=\"Permalink to Supplying your own request object\">Supplying your own request object</a></h3>\n<p>Instead of passing a path to the resource you want to request into the <code>fetch()</code> call, you can create a request object using the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Request/Request\" title=\"Request()\"><code>Request()</code></a> constructor, and pass that in as a <code>fetch()</code> method argument:</p>\n<pre><code>const myHeaders = new Headers();\n\nconst myRequest = new Request('flowers.jpg', {\n  method: 'GET',\n  headers: myHeaders,\n  mode: 'cors',\n  cache: 'default',\n});\n\nfetch(myRequest)\n  .then(response => response.blob())\n  .then(myBlob => {\n    myImage.src = URL.createObjectURL(myBlob);\n  });\n</code></pre>\n<p><code>Request()</code> accepts exactly the same parameters as the <code>fetch()</code> method. You can even pass in an existing request object to create a copy of it:</p>\n<pre><code>const anotherRequest = new Request(myRequest, myInit);\n</code></pre>\n<p>This is pretty useful, as request and response bodies are one use only. Making a copy like this allows you to make use of the request/response again while varying the <code>init</code> options if desired. The copy must be made before the body is read, and reading the body in the copy will also mark it as read in the original request.</p>\n<p><strong>Note:</strong> There is also a <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Request/clone\" title=\"clone()\"><code>clone()</code></a> method that creates a copy. Both methods of creating a copy will fail if the body of the original request or response has already been read, but reading the body of a cloned response or request will not cause it to be marked as read in the original.</p>\n<p>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Headers\"><code>Headers</code></a> interface allows you to create your own headers object via the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers\" title=\"Headers()\"><code>Headers()</code></a> constructor. A headers object is a simple multi-map of names to values:</p>\n<pre><code>const content = 'Hello World';\nconst myHeaders = new Headers();\nmyHeaders.append('Content-Type', 'text/plain');\nmyHeaders.append('Content-Length', content.length.toString());\nmyHeaders.append('X-Custom-Header', 'ProcessThisImmediately');\n</code></pre>\n<p>The same can be achieved by passing an array of arrays or an object literal to the constructor:</p>\n<pre><code>const myHeaders = new Headers({\n  'Content-Type': 'text/plain',\n  'Content-Length': content.length.toString(),\n  'X-Custom-Header': 'ProcessThisImmediately'\n});\n</code></pre>\n<p>The contents can be queried and retrieved:</p>\n<pre><code>console.log(myHeaders.has('Content-Type')); // true\nconsole.log(myHeaders.has('Set-Cookie')); // false\nmyHeaders.set('Content-Type', 'text/html');\nmyHeaders.append('X-Custom-Header', 'AnotherValue');\n\nconsole.log(myHeaders.get('Content-Length')); // 11\nconsole.log(myHeaders.get('X-Custom-Header')); // ['ProcessThisImmediately', 'AnotherValue']\n\nmyHeaders.delete('X-Custom-Header');\nconsole.log(myHeaders.get('X-Custom-Header')); // null\n</code></pre>\n<p>Some of these operations are only useful in <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\" title=\"ServiceWorkers\"><code>ServiceWorkers</code></a>, but they provide a much nicer API for manipulating headers.</p>\n<p>All of the Headers methods throw a <code>TypeError</code> if a header name is used that is not a valid HTTP Header name. The mutation operations will throw a <code>TypeError</code> if there is an immutable guard (<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#guard\">see below</a>). Otherwise, they fail silently. For example:</p>\n<pre><code>const myResponse = Response.error();\ntry {\n  myResponse.headers.set('Origin', 'http://mybank.com');\n} catch (e) {\n  console.log('Cannot pretend to be a bank!');\n}\n</code></pre>\n<p>A good use case for headers is checking whether the content type is correct before you process it further. For example:</p>\n<pre><code>fetch(myRequest)\n  .then(response => {\n     const contentType = response.headers.get('content-type');\n     if (!contentType || !contentType.includes('application/json')) {\n       throw new TypeError(\"Oops, we haven't got JSON!\");\n     }\n     return response.json();\n  })\n  .then(data => {\n      /* process your data further */\n  })\n  .catch(error => console.error(error));\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#guard\" title=\"Permalink to Guard\">Guard</a></h3>\n<p>Since headers can be sent in requests and received in responses, and have various limitations about what information can and should be mutable, headers' objects have a <em>guard</em> property. This is not exposed to the Web, but it affects which mutation operations are allowed on the headers object.</p>\n</details>\n<h1>Fetch</h1>\n<pre><code class=\"language-js\">fetch('/data.json')  .then(response => response.json())  .then(data => {    console.log(data)  })  .catch(err => ...)\n</code></pre>\n<h3>Response</h3>\n<pre><code class=\"language-js\">fetch('/data.json').then(res => {  res.text()       // response body (=> Promise)  res.json()       // parse via JSON (=> Promise)  res.status       //=> 200  res.statusText   //=> 'OK'  res.redirected   //=> false  res.ok           //=> true  res.url          //=> 'http://site.com/data.json'  res.type         //=> 'basic'                   //   ('cors' 'default' 'error'                   //    'opaque' 'opaqueredirect')\n</code></pre>\n<pre><code class=\"language-js\">  res.headers.get('Content-Type')})\n</code></pre>\n<h3>Request options</h3>\n<pre><code class=\"language-js\">fetch('/data.json', {  method: 'post',  body: new FormData(form), // post body  body: JSON.stringify(...),\n</code></pre>\n<pre><code class=\"language-js\">  headers: {    'Accept': 'application/json'  },\n</code></pre>\n<pre><code class=\"language-js\">  credentials: 'same-origin', // send cookies  credentials: 'include',     // send cookies, even in CORS\n</code></pre>\n<pre><code class=\"language-js\">})\n</code></pre>\n<h3>Catching errors</h3>\n<pre><code class=\"language-js\">fetch('/data.json')  .then(checkStatus)\n</code></pre>\n<pre><code class=\"language-js\">function checkStatus (res) {  if (res.status >= 200 &#x26;&#x26; res.status &#x3C; 300) {    return res  } else {    let err = new Error(res.statusText)    err.response = res    throw err  }}\n</code></pre>\n<p>Non-2xx responses are still successful requests. Use another function to turn them to errors.</p>\n<h3>Using with node.js</h3>\n<pre><code class=\"language-js\">const fetch = require('isomorphic-fetch')\n</code></pre>\n<p>See: <a href=\"https://npmjs.com/package/isomorphic-fetch\">isomorphic-fetch</a> <em>(npmjs.com)</em></p>"}