{"expireTime":9007200904342771000,"key":"transformer-remark-markdown-html-03d2c4b0a2d548e85c3c2d88397c50db--","val":"<h2>Sorting Algorithms</h2>\n<h3>Sorting Algorithms</h3>\n<ol>\n<li>Explain the complexity of and write a function that performs bubble sort on an array of numbers.</li>\n<li>Time Complexity: O(n^2)</li>\n<li>\n<ul>\n<li>In our worst case, our input is in the opposite order. We have to perform n swaps and loop through our input n times because a swap is made each</li>\n</ul>\n</li>\n<li>\n<p>Space Complexity: O(1)</p>\n<ul>\n<li>We are creating the same number of variables with an exact size, independent of our input. No new arrays are created.</li>\n</ul>\n</li>\n<li>Code example for bubbleSort:</li>\n</ol>\n<hr>\n<pre><code class=\"language-js\">function bubbleSort(array) {\n    // We could have also had a 'sorted = false' flag and flipped our logic below\n    let swapped = true;\n\n    while (swapped) {\n        swapped = false;\n\n        for (let i = 0; i &#x3C; array.length - 1; i++) {\n            if (array[i] > array[i + 1]) {\n                let temp = array[i];\n                array[i] = array[i + 1];\n                array[i + 1] = temp;\n                // The above three lines could also be in a helper swap function\n                // swap(array, i, i+1);\n                swapped = true;\n            }\n        }\n    }\n\n    return array;\n}\n</code></pre>\n<ol start=\"2\">\n<li>Explain the complexity of and write a function that performs selection sort on an array of numbers.</li>\n<li>\n<p>Time Complexity: O(n^2)</p>\n<ul>\n<li>Our nested loop structure is dependent on the size of our input.</li>\n<li>The outer loop always occurs n times.</li>\n<li>For each of those iterations, we have another loop that runs (n - i) times. This just means that the inner loop runs one less time each iteration, but this averages out to (n/2).</li>\n<li>Our nested structure is then T(n * n/2) = O(n^2)</li>\n</ul>\n</li>\n<li>Space Complexity: O(1)</li>\n<li>\n<ul>\n<li>We are creating the same number of variables with an exact size, independent of our input. No new arrays are created.</li>\n</ul>\n</li>\n<li>Code example for selectSort:</li>\n</ol>\n<hr>\n<pre><code class=\"language-js\">function selectionSort(arr) {\n    for (let i = 0; i &#x3C; arr.length; i++) {\n        let minIndex = i;\n\n        for (let j = i + 1; j &#x3C; arr.length; j++) {\n            if (arr[minIndex] > arr[j]) {\n                minIndex = j;\n            }\n        }\n\n        let temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n        // The above three lines could also be in a helper swap function\n        // swap(arr, i, minIndex);\n    }\n    return arr;\n}\n</code></pre>\n<ol start=\"3\">\n<li>Explain the complexity of and write a function that performs insertion sort on an array of numbers.</li>\n<li>\n<p>Time Complexity: O(n^2)</p>\n<ul>\n<li>Our nested loop structure is dependent on the size of our input.</li>\n<li>The outer loop always occurs n times.</li>\n<li>For each of those iterations, we have another loop that runs a maximum of (i - 1) times. This just means that the inner loop runs one more time each iteration, but this averages out to (n/2).</li>\n<li>Our nested structure is then T(n * n/2) = O(n^2)</li>\n</ul>\n</li>\n<li>Space Complexity: O(1)</li>\n<li>\n<ul>\n<li>We are creating the same number of variables with an exact size, independent of our input. No new arrays are created.</li>\n</ul>\n</li>\n<li>Code example for insertionSort:</li>\n</ol>\n<hr>\n<pre><code class=\"language-js\">function insertionSort(arr) {\n    for (let i = 1; i &#x3C; arr.length; i++) {\n        let currElement = arr[i];\n        for (var j = i - 1; j >= 0 &#x26;&#x26; currElement &#x3C; arr[j]; j--) {\n            arr[j + 1] = arr[j];\n        }\n        arr[j + 1] = currElement;\n    }\n    return arr;\n}\n</code></pre>\n<ol start=\"4\">\n<li>Explain the complexity of and write a function that performs merge sort on an array of numbers.</li>\n<li>\n<p>Time Complexity: O(n log n)</p>\n<ul>\n<li>Our mergeSort function divides our input in half at each step, recursively calling itself with smaller and smaller input. This results in log n stack frames.</li>\n<li>On each stack frame, our worst case scenario is having to make n comparisons in our merge function in order to determine which element should come next in our sorted array.</li>\n<li>Since we have log n stack frames and n operations on each frame, we end up with an O(n log n) time complexity</li>\n</ul>\n</li>\n<li>Space Complexity: O(n)</li>\n<li>\n<ul>\n<li>We are ultimately creating n subarrays, making our space complexity linear to our input size.</li>\n</ul>\n</li>\n<li>Code example for mergeSort:</li>\n</ol>\n<pre><code class=\"language-js\">// The merge function is what is combining our sorted sub-arrays\nfunction merge(array1, array2) {\n    let merged = [];\n\n    // keep running while either array still contains elements\n    while (array1.length || array2.length) {\n        // if array1 is nonempty, take its the first element as ele1\n        // otherwise array1 is empty, so take Infinity as ele1\n        let ele1 = array1.length ? array1[0] : Infinity;\n\n        // do the same for array2, ele2\n        let ele2 = array2.length ? array2[0] : Infinity;\n\n        let next;\n        // remove the smaller of the eles from it's array\n        if (ele1 &#x3C; ele2) {\n            next = array1.shift();\n        } else {\n            next = array2.shift();\n        }\n\n        // and add that ele to the new array\n        merged.push(next);\n    }\n\n    return merged;\n}\n\n// The mergeSort function breaks apart our input into smaller sub-arrays until we have an input of length &#x3C;= 1, which is inherently sorted.\n// Once we have a left and right subarray that's sorted, we can merge them together to get our sorted result of this sub-problem, passing the sorted version back up the call stack.\nfunction mergeSort(array) {\n    if (array.length &#x3C;= 1) {\n        return array;\n    }\n\n    let midIdx = Math.floor(array.length / 2);\n    let leftHalf = array.slice(0, midIdx);\n    let rightHalf = array.slice(midIdx);\n\n    let sortedLeft = mergeSort(leftHalf);\n    let sortedRight = mergeSort(rightHalf);\n\n    return merge(sortedLeft, sortedRight);\n}\n</code></pre>\n<ol start=\"5\">\n<li>Explain the complexity of and write a function that performs quick sort on an array of numbers.</li>\n<li>\n<p>Time Complexity: Average O(n log n), Worst O(n^2)</p>\n<ul>\n<li>In our worst case, the pivot that we select results in every element going into either the left or right array. If this happens we end up making n recursive calls to quickSort, with n comparisons at each call.</li>\n<li>In our average case, we pick something that more evenly splits the arrays, resulting in approximately log n recursive calls and an overall complexity of O(n log n).</li>\n<li>Quick sort is unique in that the worst case is so exceedingly rare that it is often considered an O(n log n) complexity, even though this is not technically accurate.</li>\n</ul>\n</li>\n<li>\n<p>Space Complexity: Our implementation O(n), Possible implementation O(log n)</p>\n<ul>\n<li>The partition arrays that we create are directly proportional to the size of the input, resulting in O(n) space complexity.</li>\n<li>With some tweaking, we could implement an in-place quick sort, which would eliminate the creation of new arrays. In this case, the log n stack frames from the recursion are the only proportional amount of space that is used, resulting in O(log n) space complexity.</li>\n</ul>\n</li>\n<li>Code example for quickSort:</li>\n</ol>\n<hr>\n<pre><code class=\"language-js\">function quickSort(array) {\n    if (array.length &#x3C;= 1) {\n        return array;\n    }\n\n    let pivot = array.shift();\n    // This implementation uses filter, which returns a new array with any element that passes the criteria (ie the callback returns true).\n    // We also could have iterated over the array (array.forEach(el => ...)) and pushed each value into the appropriate left/right subarray as we encountered it.\n    let left = array.filter((el) => el &#x3C; pivot);\n    let right = array.filter((el) => el >= pivot);\n\n    let leftSorted = quickSort(left);\n    let rightSorted = quickSort(right);\n\n    return [...leftSorted, pivot, ...rightSorted];\n    // We also could have concatenated the arrays instead of spreading their contents\n    // return leftSorted.concat([pivot]).concat(rightSorted);\n}\n</code></pre>\n<ol start=\"6\">\n<li>Explain the complexity of and write a function that performs a binary search on a sorted array of numbers.</li>\n<li>Time Complexity: O(log n)</li>\n<li>\n<ul>\n<li>With each recursive call, we split our input in half. This means we have to make at most log n checks to know if the element is in our array.</li>\n</ul>\n</li>\n<li>\n<p>Space Complexity: Our implementation O(n), Possible implementation O(1)</p>\n<ul>\n<li>We have to make a subarray for each recursive call. In the worst case (we don't find the element), the total length of these arrays is approximately equal to the length of the original (n).</li>\n<li>If we kept references to the beginning and end index of the portion of the array that we are searching, we could eliminate the need for creating new subarrays. We could also use a while loop to perform this functionality until we either found our target or our beginning and end indices crossed. This would eliminate the space required for recursive calls (adding stack frames). Ultimately we would be using the same number of variables independent of input size, resulting in O(1).</li>\n</ul>\n</li>\n<li>Code example for binarySearch and binarySearchIndex:</li>\n</ol>\n<pre><code class=\"language-js\">// Returns simply true/false for presence\nfunction binarySearch(array, target) {\n    if (array.length === 0) {\n        return false;\n    }\n\n    let midIdx = Math.floor(array.length / 2);\n    let leftHalf = array.slice(0, midIdx);\n    let rightHalf = array.slice(midIdx + 1);\n\n    if (target &#x3C; array[midIdx]) {\n        return binarySearch(leftHalf, target);\n    } else if (target > array[midIdx]) {\n        return binarySearch(rightHalf, target);\n    } else {\n        return true;\n    }\n}\n\n// Returns the index or -1 if not found\nfunction binarySearchIndex(array, target) {\n    if (!array.length) return -1;\n\n    const midIdx = Math.floor(array.length / 2);\n    const midEl = array[midIdx];\n\n    if (target &#x3C; midEl) {\n        return binarySearchIndex(array.slice(0, midIdx), target);\n    } else if (target > midEl) {\n        // Since our recursive call will have new indices for the subarray, we have to adjust the return value to align it with the indices of our original array.\n        // If the recursive call returns -1, it was not found and we can immediately return -1\n        // If it was found in the subarray, we have to add on the number of elements that were removed from the beginning of our larger original array.\n        // For example, if we try to find 15 in an array of [5, 10, 15]:\n        // - Our first call to binarySearchIndex will check our middle element of 10\n        // - Since our target is greater, we will recursively call our search on elements to the right, being the subarray [15]\n        // - On our recursive call we found our target! It's index in this call is 0.\n        // - When we return 0 to where binarySearchIndex was called, we need to adjust it to line up with this larger array (the 0th element of this larger array is 5, but our target was at the 0th index of the subarray)\n        // - Since we sliced off 2 elements from the beginning before making our recursive call, we add 2 to the return value to adjust it back to line up with our original array.\n        const idxShift = binarySearchIndex(array.slice(midIdx + 1), target);\n        return idxShift === -1 ? -1 : idxShift + midIdx + 1;\n    } else {\n        return midIdx;\n    }\n}\n</code></pre>"}